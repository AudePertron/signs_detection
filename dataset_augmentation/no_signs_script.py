import os
from bs4 import BeautifulSoup
from config import config

from imutils import paths
import cv2
import os

totalPositive = 0
totalNegative = 0
def compute_iou(boxA, boxB):
	# determine the (x, y)-coordinates of the intersection rectangle
	xA = max(boxA[0], boxB[0])
	yA = max(boxA[1], boxB[1])
	xB = min(boxA[2], boxB[2])
	yB = min(boxA[3], boxB[3])
	# compute the area of intersection rectangle
	interArea = max(0, xB - xA + 1) * max(0, yB - yA + 1)
	# compute the area of both the prediction and ground-truth
	# rectangles
	boxAArea = (boxA[2] - boxA[0] + 1) * (boxA[3] - boxA[1] + 1)
	boxBArea = (boxB[2] - boxB[0] + 1) * (boxB[3] - boxB[1] + 1)
	# compute the intersection over union by taking the intersection
	# area and dividing it by the sum of prediction + ground-truth
	# areas - the intersection area
	iou = interArea / float(boxAArea + boxBArea - interArea)
	# return the intersection over union value
	return iou





rows = open('dataset/Train.csv').read().strip().split("\n")
i=0
# loop over the rows
for row in rows:

    while i<500:
        i=i+1
        # break the row into the filename, bounding box coordinates,
        # and class label
        
        
        (filename, startX, startY, endX, endY, label) = row.split(";")
            # derive the path to the input image, load the image (in
        # OpenCV format), and grab its dimensions

        gtBox=(int(startX), int(startY), int(endX), int(endY))

        imagePath = filename
        
            # load the input image from disk
        image = cv2.imread(imagePath)
        newHeight = 500
        newWidth = int(image.shape[1]*500/image.shape[0])
        image = cv2.resize(image, (newWidth, newHeight)) 

        cv2.setUseOptimized(True)
        cv2.setNumThreads(16)

        if type(image)!=type(None):

            # run selective search on the image and initialize our list of
            # proposed boxes
            ss = cv2.ximgproc.segmentation.createSelectiveSearchSegmentation()
            ss.setBaseImage(image)
            ss.switchToSelectiveSearchFast()
            rects = ss.process()
            proposedRects= []
            # loop over the rectangles generated by selective search
            for (x, y, w, h) in rects[:100]:
                # convert our bounding boxes from (x, y, w, h) to (startX,
                # startY, startX, endY)
                
                proposedRects.append((x, y, x + w, y + h))

            # initialize counters used to count the number of positive and
            # negative ROIs saved thus far
            positiveROIs = 0
            negativeROIs = 0
            # loop over the maximum number of region proposals
            for proposedRect in proposedRects[:config.MAX_PROPOSALS]:
                # unpack the proposed rectangle bounding box
                
                (propStartX, propStartY, propEndX, propEndY) = proposedRect
                # loop over the ground-truth bounding boxes
                iou = compute_iou(gtBox, proposedRect)
                (gtStartX, gtStartY, gtEndX, gtEndY) = gtBox

                # initialize the ROI and output path
                roi = None
                outputPath = None

                fullOverlap = propStartX >= gtStartX
                fullOverlap = fullOverlap and propStartY >= gtStartY
                fullOverlap = fullOverlap and propEndX <= gtEndX
                fullOverlap = fullOverlap and propEndY <= gtEndY
                # check to see if there is not full overlap *and* the IoU
                # is less than 5% *and* we have not hit our negative
                # count limit
                if not fullOverlap and iou < 0.05 and \
                    negativeROIs <= config.MAX_NEGATIVE:
                    # extract the ROI and then derive the output path to
                    # the negative instance
                    roi = image[propStartY:propEndY, propStartX:propEndX]
                    filename = "{}.png".format(totalNegative+1000)
                    outputPath = config.NEGATIVE_PATH+"/"+filename
                    # increment the negative counters
                    negativeROIs += 1
                    totalNegative += 1

                    roi = cv2.resize(roi, config.INPUT_DIMS,
                        interpolation=cv2.INTER_CUBIC)

                    status=cv2.imwrite(outputPath, roi)
                    print(status)